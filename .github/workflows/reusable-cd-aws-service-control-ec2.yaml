# Reusable workflow for controlling EC2 instances (start/stop)
# This workflow can start or stop EC2 instances with automatic resource discovery
name: reusable-cd-aws-service-control-ec2

on:
  workflow_call:
    inputs:
      action:
        description: "Action to perform (start or stop)"
        required: true
        type: string
      auto_discover:
        description: "Automatically discover EC2 instances (if true, instances input is ignored)"
        required: false
        type: boolean
        default: false
      environment:
        description: "Target environment (dev, qa, stg, prd, etc.)"
        required: true
        type: string
      exclude_patterns:
        description: "JSON array of patterns to exclude from auto-discovery (partial match on instance ID or Name tag) ['pattern1', 'pattern2']"
        required: false
        type: string
        default: "[]"
      include_patterns:
        description: "JSON array of patterns to include in auto-discovery (partial match). If empty, all are included ['pattern1', 'pattern2']"
        required: false
        type: string
        default: "[]"
      instances:
        description: "JSON array of EC2 instance IDs to control ['i-xxxxx', 'i-yyyyy']"
        required: false
        type: string
        default: "[]"
      wait_for_stable:
        description: "Wait for instance to reach desired state after operation (set to false to skip waiting)"
        required: false
        type: boolean
        default: true
    secrets:
      AWS_IAM_ROLE_ARN:
        required: true
      AWS_REGION:
        required: true

permissions: {}

env:
  ACTION: ${{ inputs.action }}
  AUTO_DISCOVER: ${{ inputs.auto_discover }}
  EXCLUDE_PATTERNS: ${{ inputs.exclude_patterns }}
  INCLUDE_PATTERNS: ${{ inputs.include_patterns }}
  INSTANCES: ${{ inputs.instances }}

jobs:
  discover-instances:
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    environment:
      name: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
    outputs:
      discovered_instances_b64: ${{ steps.discover.outputs.discovered_instances_b64 }}
    steps:
      - name: Setup AWS Credentials
        uses: aws-actions/configure-aws-credentials@8df5847569e6427dd6c4fb1cf565c83acfa8afa7 # v6.0.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}

      - name: Discover EC2 Instances
        id: discover
        shell: bash
        run: |
          set -euo pipefail

          # Helper: Check jq availability
          check_jq() {
            command -v jq >/dev/null 2>&1 || { echo "‚ùå jq is required"; exit 1; }
          }

          # Short-circuit when auto-discover is disabled
          if [[ "$AUTO_DISCOVER" != "true" ]]; then
            echo "discovered_instances=[]" >> "$GITHUB_OUTPUT"
            echo "discovered_instances_b64=" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è Auto-discover disabled"
            exit 0
          fi

          check_jq

          echo "üîç Discovering EC2 instances..."

          # shellcheck disable=SC2016
          INSTANCES_DATA=$(aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running,stopped" \
            --query 'Reservations[].Instances[].[InstanceId, Tags[?Key==`Name`].Value | [0]]' \
            --output json)

          # Parse and filter instances
          FILTERED_INSTANCES=()
          INCLUDE_PATTERNS_ARRAY=$(echo "$INCLUDE_PATTERNS" | jq -r '.[]' 2>/dev/null || echo "")
          EXCLUDE_PATTERNS_ARRAY=$(echo "$EXCLUDE_PATTERNS" | jq -r '.[]' 2>/dev/null || echo "")

          while IFS= read -r line; do
            INSTANCE_ID=$(echo "$line" | jq -r '.[0]')
            INSTANCE_NAME=$(echo "$line" | jq -r '.[1] // ""')

            # Check exclude patterns
            EXCLUDED=false
            if [[ -n "$EXCLUDE_PATTERNS_ARRAY" ]]; then
              while IFS= read -r pattern; do
                if [[ "$INSTANCE_ID" == *"$pattern"* ]] || [[ "$INSTANCE_NAME" == *"$pattern"* ]]; then
                  echo "  ‚äñ Excluding: $INSTANCE_ID ($INSTANCE_NAME) [matched exclude pattern: $pattern]"
                  EXCLUDED=true
                  break
                fi
              done <<< "$EXCLUDE_PATTERNS_ARRAY"
            fi

            [[ "$EXCLUDED" == true ]] && continue

            # Check include patterns
            if [[ -n "$INCLUDE_PATTERNS_ARRAY" ]]; then
              INCLUDED=false
              while IFS= read -r pattern; do
                if [[ "$INSTANCE_ID" == *"$pattern"* ]] || [[ "$INSTANCE_NAME" == *"$pattern"* ]]; then
                  INCLUDED=true
                  break
                fi
              done <<< "$INCLUDE_PATTERNS_ARRAY"

              if [[ "$INCLUDED" == false ]]; then
                echo "  ‚äñ Skipping: $INSTANCE_ID ($INSTANCE_NAME) [no include pattern matched]"
                continue
              fi
            fi

            echo "  ‚úì Discovered: $INSTANCE_ID ($INSTANCE_NAME)"
            FILTERED_INSTANCES+=("\"$INSTANCE_ID\"")
          done < <(echo "$INSTANCES_DATA" | jq -c '.[]')

          # Create JSON array
          if [ ${#FILTERED_INSTANCES[@]} -eq 0 ]; then
            DISCOVERED_JSON='[]'
          else
            DISCOVERED_JSON=$(printf '%s\n' "${FILTERED_INSTANCES[@]}" | jq -s .)
          fi

          # echo "discovered_instances=$DISCOVERED_JSON" >> "$GITHUB_OUTPUT"
          # Provide a base64-encoded form to avoid unsafe template expansion in downstream steps
          DISCOVERED_B64=$(printf '%s' "$DISCOVERED_JSON" | base64 -w0)
          echo "discovered_instances_b64=$DISCOVERED_B64" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Discovered ${#FILTERED_INSTANCES[@]} EC2 instance(s)"
          printf '%s' "$DISCOVERED_JSON" | jq .

  validate:
    needs: [discover-instances]
    if: ${{ always() && github.actor != 'dependabot[bot]' && (needs.discover-instances.result == 'success' || needs.discover-instances.result == 'skipped') }}
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      action_validated: ${{ steps.validate-inputs.outputs.action }}
      target_instances: ${{ steps.validate-inputs.outputs.target_instances }}
    steps:
      - name: Validate inputs
        id: validate-inputs
        shell: bash
        env:
          DISCOVERED_B64: ${{ needs.discover-instances.outputs.discovered_instances_b64 }}
        run: |
          set -euo pipefail
          # Validate action
          if [[ "$ACTION" != "start" && "$ACTION" != "stop" ]]; then
            echo "‚ùå Error: action must be 'start' or 'stop', got '$ACTION'"
            exit 1
          fi
          echo "action=$ACTION" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Action validated: $ACTION"

          # Determine target instances (use base64-decoded discovered data to avoid unsafe template expansion)
          if [[ "$AUTO_DISCOVER" == "true" ]]; then
            if [[ -n "${DISCOVERED_B64:-}" ]]; then
              TARGET_INSTANCES=$(printf '%s' "$DISCOVERED_B64" | base64 --decode)
            else
              TARGET_INSTANCES='[]'
            fi
            echo "Using auto-discovered instances"
          else
            TARGET_INSTANCES="$INSTANCES"
            echo "Using manually specified instances"
          fi

          # Validate instances JSON format
          if ! printf '%s' "$TARGET_INSTANCES" | jq empty 2>/dev/null; then
            echo "‚ùå Error: instances is not valid JSON"
            exit 1
          fi

          # Validate at least one instance is selected
          INSTANCE_COUNT=$(printf '%s' "$TARGET_INSTANCES" | jq '. | length')
          if [[ "$INSTANCE_COUNT" -eq 0 ]]; then
            echo "‚ö†Ô∏è  Warning: No EC2 instances found (skipping control)"
            echo "target_instances=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Emit sanitized output (compact JSON)
          SANITIZED_INSTANCES=$(printf '%s' "$TARGET_INSTANCES" | jq -c '.')
          echo "target_instances=$SANITIZED_INSTANCES" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Target instances count: $INSTANCE_COUNT"
          printf '%s' "$SANITIZED_INSTANCES" | jq .

  control-instances:
    needs: validate
    if: ${{ github.actor != 'dependabot[bot]' && needs.validate.result == 'success' && needs.validate.outputs.target_instances != '[]' }}
    runs-on: ubuntu-24.04
    timeout-minutes: 30
    concurrency:
      group: ec2-control-${{ inputs.environment }}-${{ matrix.instance }}-${{ inputs.action }}
      cancel-in-progress: false
    environment:
      name: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write
    strategy:
      fail-fast: false
      matrix:
        instance: ${{ fromJSON(needs.validate.outputs.target_instances) }}
    steps:
      - name: Setup AWS Credentials
        uses: aws-actions/configure-aws-credentials@8df5847569e6427dd6c4fb1cf565c83acfa8afa7 # v6.0.0
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}

      - name: Control EC2 Instance
        env:
          INSTANCE_ID: ${{ matrix.instance }}
        shell: bash
        run: |
          if [[ "$ACTION" == "stop" ]]; then
            echo "üõë Stopping EC2 instance: $INSTANCE_ID"
            # run command and capture stderr; ignore if instance already stopped
            ERR=$(aws ec2 stop-instances --instance-ids "$INSTANCE_ID" 2>&1) || RC=$?
            if [ "${RC:-0}" -ne 0 ]; then
              if echo "$ERR" | grep -qiE "already.*stopped|InvalidInstanceID\.NotFound"; then
                echo "‚ÑπÔ∏è EC2 instance is already stopped or not found (ignoring): $ERR"
              else
                echo "$ERR"
                exit "${RC:-1}"
              fi
            else
              echo "‚úÖ Stop command sent for EC2 instance: $INSTANCE_ID"
            fi

          elif [[ "$ACTION" == "start" ]]; then
            echo "‚ñ∂Ô∏è  Starting EC2 instance: $INSTANCE_ID"
            ERR=$(aws ec2 start-instances --instance-ids "$INSTANCE_ID" 2>&1) || RC=$?
            if [ "${RC:-0}" -ne 0 ]; then
              if echo "$ERR" | grep -qiE "already.*running|InvalidInstanceID\.NotFound"; then
                echo "‚ÑπÔ∏è EC2 instance is already running or not found (ignoring): $ERR"
              else
                echo "$ERR"
                exit "${RC:-1}"
              fi
            else
              echo "‚úÖ Start command sent for EC2 instance: $INSTANCE_ID"
            fi
          fi

      - name: Wait for EC2 Instance Status
        if: ${{ inputs.wait_for_stable }}
        timeout-minutes: 10
        env:
          INSTANCE_ID: ${{ matrix.instance }}
        shell: bash
        run: |
          EXPECTED_STATUS="running"
          if [[ "$ACTION" == "stop" ]]; then
            EXPECTED_STATUS="stopped"
          fi

          echo "‚è≥ Waiting for EC2 instance to reach status: $EXPECTED_STATUS"

          for i in {1..60}; do
            STATUS=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text)

            echo "Current status: $STATUS (attempt $i/60)"

            if [[ "$STATUS" == "$EXPECTED_STATUS" ]]; then
              echo "‚úÖ EC2 instance reached expected status: $EXPECTED_STATUS"
              exit 0
            fi

            sleep 30
          done

          echo "‚ö†Ô∏è  Warning: EC2 instance did not reach expected status within timeout"
          exit 1
